# 08 - æŠ€æœ¯éš¾ç‚¹ä¸è§£å†³æ–¹æ¡ˆ

[â† è¿”å›ä¸»ç›®å½•](../README.md)

---

## ğŸ¯ æ ¸å¿ƒæŠ€æœ¯æŒ‘æˆ˜

---

## 1ï¸âƒ£ LLM è¾“å‡ºæ ¼å¼ä¸ç¨³å®š

### é—®é¢˜æè¿°
- AIæ¨¡å‹å¯èƒ½è¿”å›éæ ‡å‡†JSON
- å¯èƒ½åŒ…å«é¢å¤–æ–‡å­—è¯´æ˜
- ä¸åŒæ¨¡å‹æ ¼å¼åå¥½ä¸åŒ
- å¶å°”ä¼šç”Ÿæˆæ— æ•ˆJSON

### çœŸå®æ¡ˆä¾‹

**æœŸæœ›è¾“å‡º**ï¼š
```json
{
  "action": "BUY",
  "coin": "BTC",
  "leverage": 10,
  "confidence": 75
}
```

**å®é™…å¯èƒ½æ”¶åˆ°**ï¼š
```
Based on my analysis, I believe we should buy BTC.

```json
{
  "action": "BUY",
  "coin": "BTC",
  "leverage": 10,
  "confidence": 75,
  "reasoning": "Strong support at $100k"
}
```

This is a good opportunity because...
```

### è§£å†³æ–¹æ¡ˆ

#### æ–¹æ¡ˆ1ï¼šå¤šå±‚æ¬¡è§£æå™¨

```typescript
function parseLLMResponse(responseText: string): TradingDecision {
  // ç¬¬1å±‚ï¼šå°è¯•ç›´æ¥è§£æ
  try {
    return JSON.parse(responseText);
  } catch (e1) {
    // ç»§ç»­å°è¯•å…¶ä»–æ–¹æ³•
  }
  
  // ç¬¬2å±‚ï¼šæå–JSONä»£ç å—
  try {
    const codeBlockMatch = responseText.match(/```json\n([\s\S]*?)\n```/);
    if (codeBlockMatch) {
      return JSON.parse(codeBlockMatch[1]);
    }
  } catch (e2) {
    // ç»§ç»­
  }
  
  // ç¬¬3å±‚ï¼šæŸ¥æ‰¾ç¬¬ä¸€ä¸ªå®Œæ•´JSONå¯¹è±¡
  try {
    const start = responseText.indexOf('{');
    const end = responseText.lastIndexOf('}') + 1;
    if (start !== -1 && end > start) {
      const jsonStr = responseText.substring(start, end);
      return JSON.parse(jsonStr);
    }
  } catch (e3) {
    // ç»§ç»­
  }
  
  // ç¬¬4å±‚ï¼šæ­£åˆ™è¡¨è¾¾å¼æå–
  try {
    const jsonRegex = /\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g;
    const matches = responseText.match(jsonRegex);
    if (matches && matches.length > 0) {
      // å°è¯•æœ€å¤§çš„JSONå¯¹è±¡
      const sorted = matches.sort((a, b) => b.length - a.length);
      return JSON.parse(sorted[0]);
    }
  } catch (e4) {
    // æœ€åå…œåº•
  }
  
  // å¤±è´¥è¿”å›é»˜è®¤HOLDå†³ç­–
  console.error('Failed to parse LLM response:', responseText);
  return {
    action: 'HOLD',
    confidence: 0,
    reasoning: 'Failed to parse AI response'
  };
}
```

#### æ–¹æ¡ˆ2ï¼šä½¿ç”¨ JSON Mode

å¯¹äºæ”¯æŒçš„æ¨¡å‹ï¼ˆOpenAI, Googleï¼‰ï¼š
```typescript
// OpenAI JSON Mode
const response = await openai.chat.completions.create({
  model: 'gpt-5',
  messages: [{ role: 'user', content: prompt }],
  response_format: { type: 'json_object' } // å¼ºåˆ¶JSONè¾“å‡º
});
```

#### æ–¹æ¡ˆ3ï¼šFew-Shotç¤ºä¾‹

åœ¨æç¤ºè¯ä¸­æä¾›ç¤ºä¾‹ï¼š
```markdown
## EXAMPLE RESPONSES

Example 1:
{
  "action": "BUY",
  "coin": "BTC",
  "direction": "LONG",
  "size_usd": 5000,
  "leverage": 10,
  "confidence": 80,
  "reasoning": "..."
}

Example 2:
{
  "action": "HOLD",
  "confidence": 60,
  "reasoning": "..."
}

## YOUR RESPONSE

(Respond in the same JSON format as above)
```

---

## 2ï¸âƒ£ äº¤æ˜“å»¶è¿Ÿä¸æ»‘ç‚¹

### é—®é¢˜æè¿°
ä»AIå†³ç­–åˆ°äº¤æ˜“æ‰§è¡Œæœ‰æ—¶é—´å»¶è¿Ÿï¼š
```
AIåˆ†æï¼ˆåŸºäº T æ—¶åˆ»ä»·æ ¼ï¼‰
  â†“ 30-60ç§’
APIè°ƒç”¨å®Œæˆ
  â†“ 5-10ç§’
é£æ§æ£€æŸ¥
  â†“ 5-10ç§’
äº¤æ˜“æ‰§è¡Œï¼ˆä»·æ ¼å¯èƒ½å·²å˜ä¸º T+60ç§’ï¼‰
```

**æ»‘ç‚¹ç¤ºä¾‹**ï¼š
- AIçœ‹åˆ°BTC=$107,000ï¼Œå†³å®šä¹°å…¥
- 60ç§’åæ‰§è¡Œæ—¶BTC=$107,500
- æ»‘ç‚¹=$500ï¼ˆ0.47%ï¼‰

### è§£å†³æ–¹æ¡ˆ

#### æ–¹æ¡ˆ1ï¼šé™ä»·å•ï¼ˆè€Œéå¸‚ä»·å•ï¼‰

```typescript
async function executeTrade(decision: TradingDecision, currentPrice: number) {
  const slippageTolerance = 0.005; // 0.5%æ»‘ç‚¹å®¹å¿åº¦
  
  const limitPrice = decision.direction === 'LONG' ?
    currentPrice * (1 + slippageTolerance) :  // åšå¤šï¼šæ¥å—æ›´é«˜ä»·
    currentPrice * (1 - slippageTolerance);   // åšç©ºï¼šæ¥å—æ›´ä½ä»·
  
  const order = await hyperliquid.placeLimitOrder({
    coin: decision.coin,
    side: decision.direction,
    size: decision.size_usd / currentPrice,
    limit_price: limitPrice,
    time_in_force: 'IOC' // Immediate or Cancel
  });
  
  return order;
}
```

#### æ–¹æ¡ˆ2ï¼šä»·æ ¼é‡æ–°ç¡®è®¤

```typescript
async function executeWithPriceCheck(decision: TradingDecision) {
  // è·å–æœ€æ–°ä»·æ ¼
  const latestPrice = await hyperliquid.getPrice(decision.coin);
  const originalPrice = decision.expected_price;
  
  // æ£€æŸ¥ä»·æ ¼å˜åŒ–
  const priceChange = Math.abs(latestPrice - originalPrice) / originalPrice;
  
  if (priceChange > 0.02) { // 2%é˜ˆå€¼
    console.warn(`Price moved ${(priceChange * 100).toFixed(2)}% since decision`);
    // å¯ä»¥é€‰æ‹©ï¼š
    // 1. å–æ¶ˆäº¤æ˜“
    // 2. é‡æ–°è¯¢é—®AI
    // 3. è°ƒæ•´äº¤æ˜“è§„æ¨¡
    return { executed: false, reason: 'Price moved too much' };
  }
  
  // ä»·æ ¼å˜åŒ–åœ¨å¯æ¥å—èŒƒå›´å†…ï¼Œæ‰§è¡Œ
  return await executeTrade(decision, latestPrice);
}
```

#### æ–¹æ¡ˆ3ï¼šåŠ å¿«æ‰§è¡Œé€Ÿåº¦

```typescript
// ä½¿ç”¨Promise.raceåŠ é€Ÿ
async function fastExecute(decision: TradingDecision) {
  const tasks = [
    executeTrade(decision),
    timeout(10000) // 10ç§’è¶…æ—¶
  ];
  
  try {
    const result = await Promise.race(tasks);
    return result;
  } catch (error) {
    console.error('Trade execution timeout or failed');
    throw error;
  }
}
```

---

## 3ï¸âƒ£ æ•°æ®ä¸€è‡´æ€§é—®é¢˜

### é—®é¢˜åœºæ™¯

**åœºæ™¯1ï¼šå¤šæ•°æ®æºä¸ä¸€è‡´**
```
Hyperliquid API: BTC = $107,500
Redisç¼“å­˜: BTC = $107,200
PostgreSQL: BTC = $107,000
```

**åœºæ™¯2ï¼šè´¦æˆ·ä»·å€¼è®¡ç®—å·®å¼‚**
```
å‰ç«¯æ˜¾ç¤º: $10,571
æ•°æ®åº“è®°å½•: $10,568
äº¤æ˜“æ‰€å®é™…: $10,575
```

### è§£å†³æ–¹æ¡ˆ

#### æ–¹æ¡ˆ1ï¼šå•ä¸€çœŸå®æ¥æºï¼ˆSource of Truthï¼‰

```typescript
// Hyperliquid API ä½œä¸ºå”¯ä¸€çœŸå®æ¥æº
async function reconcileAccountValue(modelId: string) {
  // ä»äº¤æ˜“æ‰€è·å–çœŸå®æ•°æ®
  const hyperliquidAccount = await hyperliquid.getAccountValue(modelId);
  
  // ä¸æ•°æ®åº“å¯¹æ¯”
  const dbAccount = await db.getAccountValue(modelId);
  
  constå·®å¼‚ = Math.abs(hyperliquidAccount - dbAccount);
  
  if (å·®å¼‚ > 100) { // $100å·®å¼‚é˜ˆå€¼
    console.warn(`Account value mismatch for ${modelId}: 
      Exchange: $${hyperliquidAccount}
      Database: $${dbAccount}
      Difference: $${å·®å¼‚}
    `);
    
    // ä»¥äº¤æ˜“æ‰€ä¸ºå‡†ï¼Œæ›´æ–°æ•°æ®åº“
    await db.updateAccountValue(modelId, hyperliquidAccount);
  }
}
```

#### æ–¹æ¡ˆ2ï¼šå®šæœŸå¯¹è´¦

```typescript
// æ¯å°æ—¶æ‰§è¡Œä¸€æ¬¡å¯¹è´¦
cron.schedule('0 * * * *', async () => {
  console.log('Starting account reconciliation...');
  
  const models = await db.getAllModels();
  
  for (const model of models) {
    try {
      await reconcileAccountValue(model.id);
      await reconcilePositions(model.id);
      await reconcileTrades(model.id);
    } catch (error) {
      console.error(`Reconciliation failed for ${model.id}:`, error);
      // å‘é€å‘Šè­¦
      await sendAlert(`è´¦æˆ·å¯¹è´¦å¤±è´¥: ${model.id}`);
    }
  }
  
  console.log('Reconciliation completed');
});
```

#### æ–¹æ¡ˆ3ï¼šäº‹åŠ¡å¤„ç†

```typescript
// ä½¿ç”¨æ•°æ®åº“äº‹åŠ¡ä¿è¯ä¸€è‡´æ€§
async function saveTradeWithTransaction(trade: Trade) {
  const client = await db.connect();
  
  try {
    await client.query('BEGIN');
    
    // 1. æ’å…¥äº¤æ˜“è®°å½•
    await client.query(`
      INSERT INTO trades (...) VALUES (...)
    `);
    
    // 2. æ›´æ–°æŒä»“
    await client.query(`
      UPDATE positions SET ... WHERE ...
    `);
    
    // 3. æ›´æ–°è´¦æˆ·å¿«ç…§
    await client.query(`
      INSERT INTO account_snapshots (...) VALUES (...)
    `);
    
    await client.query('COMMIT');
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}
```

---

## 4ï¸âƒ£ é«˜é¢‘æ•°æ®æ›´æ–°æ€§èƒ½

### é—®é¢˜æè¿°

**æ•°æ®æ›´æ–°é¢‘ç‡**ï¼š
- ä»·æ ¼ï¼šæ¯ç§’æ›´æ–°6ä¸ªå¸ç§
- è´¦æˆ·ä»·å€¼ï¼šæ¯ç§’æ›´æ–°7ä¸ªæ¨¡å‹
- æŒä»“ç›ˆäºï¼šæ¯ç§’é‡æ–°è®¡ç®—50+ä¸ªä»“ä½
- æ•°æ®åº“å†™å…¥å‹åŠ›ï¼š86,400æ¬¡/å¤©ï¼ˆæ¯ç§’1æ¬¡ï¼‰

**æ€§èƒ½ç“¶é¢ˆ**ï¼š
- æ•°æ®åº“æ— æ³•æ¯ç§’å†™å…¥
- å‰ç«¯æ¸²æŸ“é¢‘ç¹å¯¼è‡´å¡é¡¿
- Rediså†…å­˜å ç”¨è¿‡é«˜

### è§£å†³æ–¹æ¡ˆ

#### æ–¹æ¡ˆ1ï¼šæ‰¹é‡å†™å…¥

```typescript
// ä¸è¦æ¯æ¬¡éƒ½å†™æ•°æ®åº“
const priceBuffer: PriceUpdate[] = [];

setInterval(() => {
  const price = fetchPrice('BTC');
  priceBuffer.push({ coin: 'BTC', price, timestamp: new Date() });
}, 1000);

// æ¯åˆ†é’Ÿæ‰¹é‡å†™å…¥ä¸€æ¬¡
setInterval(async () => {
  if (priceBuffer.length > 0) {
    await db.batchInsert('price_history', priceBuffer);
    priceBuffer.length = 0; // æ¸…ç©ºç¼“å†²åŒº
  }
}, 60000); // 60ç§’
```

#### æ–¹æ¡ˆ2ï¼šæ•°æ®æŠ½æ ·

```typescript
// ä¸æ˜¯æ‰€æœ‰æ•°æ®éƒ½è¦ä¿å­˜
function shouldSavePriceSnapshot(currentPrice: number, lastSavedPrice: number): boolean {
  const changePercent = Math.abs(currentPrice - lastSavedPrice) / lastSavedPrice;
  
  // ä»…å½“ä»·æ ¼å˜åŒ–>0.1%æ—¶ä¿å­˜
  return changePercent > 0.001;
}

// æˆ–è€…å›ºå®šæ—¶é—´é—´éš”
let lastSaveTime = Date.now();
if (Date.now() - lastSaveTime > 60000) { // è‡³å°‘60ç§’
  savePriceSnapshot();
  lastSaveTime = Date.now();
}
```

#### æ–¹æ¡ˆ3ï¼šä½¿ç”¨æ—¶åºæ•°æ®åº“

```typescript
// ä½¿ç”¨TimescaleDBï¼ˆPostgreSQLæ‰©å±•ï¼‰
// å®‰è£…
// CREATE EXTENSION IF NOT EXISTS timescaledb;

// åˆ›å»ºhypertable
// SELECT create_hypertable('price_history', 'timestamp');

// è‡ªåŠ¨å‹ç¼©æ—§æ•°æ®
// SELECT add_compression_policy('price_history', INTERVAL '7 days');

// æŸ¥è¯¢æ€§èƒ½æ˜¾è‘—æå‡
const prices = await db.query(`
  SELECT 
    time_bucket('1 minute', timestamp) AS bucket,
    coin,
    AVG(price) as avg_price
  FROM price_history
  WHERE timestamp > NOW() - INTERVAL '24 hours'
  GROUP BY bucket, coin
  ORDER BY bucket DESC
`);
```

#### æ–¹æ¡ˆ4ï¼šå‰ç«¯é˜²æŠ–ä¸èŠ‚æµ

```typescript
// hooks/useThrottledData.ts
import { useEffect, useState } from 'react';
import { throttle } from 'lodash';

export function useThrottledPrices(updateInterval = 1000) {
  const [prices, setPrices] = useState({});
  
  useEffect(() => {
    // èŠ‚æµæ›´æ–°å‡½æ•°
    const throttledUpdate = throttle(async () => {
      const newPrices = await fetchPrices();
      setPrices(newPrices);
    }, updateInterval);
    
    // WebSocketç›‘å¬
    socket.on('prices:update', throttledUpdate);
    
    return () => {
      socket.off('prices:update', throttledUpdate);
      throttledUpdate.cancel();
    };
  }, []);
  
  return prices;
}
```

---

## 5ï¸âƒ£ Hyperliquid API é™åˆ¶

### é—®é¢˜æè¿°
- APIè¯·æ±‚é€Ÿç‡é™åˆ¶
- å¶å°”çš„ç½‘ç»œè¶…æ—¶
- è®¢å•å¯èƒ½éƒ¨åˆ†æˆäº¤
- ä»·æ ¼ç²¾åº¦è¦æ±‚

### è§£å†³æ–¹æ¡ˆ

#### é€Ÿç‡é™åˆ¶å¤„ç†

```typescript
// lib/hyperliquid/rateLimiter.ts
class RateLimiter {
  private queue: Array<() => Promise<any>> = [];
  private processing = false;
  private readonly maxPerSecond = 10;
  private readonly delay = 1000 / this.maxPerSecond;
  
  async execute<T>(fn: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          const result = await fn();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
      
      if (!this.processing) {
        this.process();
      }
    });
  }
  
  private async process() {
    this.processing = true;
    
    while (this.queue.length > 0) {
      const task = this.queue.shift();
      if (task) {
        await task();
        await this.sleep(this.delay);
      }
    }
    
    this.processing = false;
  }
  
  private sleep(ms: number) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

const limiter = new RateLimiter();

// ä½¿ç”¨
const result = await limiter.execute(() => 
  hyperliquid.placeOrder(params)
);
```

#### é‡è¯•æœºåˆ¶

```typescript
async function hyperliquidWithRetry<T>(
  operation: () => Promise<T>,
  maxRetries = 3
): Promise<T> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await operation();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      // åˆ¤æ–­æ˜¯å¦æ˜¯å¯é‡è¯•é”™è¯¯
      if (error.code === 'ETIMEDOUT' || 
          error.code === 'ECONNRESET' ||
          error.status === 429) {
        const delay = Math.pow(2, i) * 1000; // æŒ‡æ•°é€€é¿
        console.log(`Retry ${i + 1}/${maxRetries} after ${delay}ms`);
        await sleep(delay);
      } else {
        throw error; // ä¸å¯é‡è¯•é”™è¯¯ç›´æ¥æŠ›å‡º
      }
    }
  }
  
  throw new Error('Max retries reached');
}
```

---

## 6ï¸âƒ£ å®æ—¶æ€§ä¸å‡†ç¡®æ€§å¹³è¡¡

### é—®é¢˜æè¿°
- è¿½æ±‚å®æ—¶æ€§ï¼šæ•°æ®å¯èƒ½ä¸å‡†ç¡®
- è¿½æ±‚å‡†ç¡®æ€§ï¼šæ˜¾ç¤ºä¼šæœ‰å»¶è¿Ÿ
- å‰ç«¯æ˜¾ç¤ºä¸å®é™…çŠ¶æ€å¯èƒ½ä¸åŒæ­¥

### è§£å†³æ–¹æ¡ˆ

#### åˆ†å±‚æ•°æ®ç­–ç•¥

```typescript
// ä¸‰å±‚æ•°æ®æº
const dataLayers = {
  // ç¬¬1å±‚ï¼šRedisï¼ˆè¶…å¿«ä½†å¯èƒ½ç•¥æ—§ï¼‰
  fast: async () => {
    return await redis.get('leaderboard:current');
  },
  
  // ç¬¬2å±‚ï¼šç‰©åŒ–è§†å›¾ï¼ˆå¿«ä¸”ç›¸å¯¹å‡†ç¡®ï¼‰
  medium: async () => {
    return await db.query('SELECT * FROM leaderboard_current');
  },
  
  // ç¬¬3å±‚ï¼šå®æ—¶è®¡ç®—ï¼ˆæ…¢ä½†ç»å¯¹å‡†ç¡®ï¼‰
  accurate: async () => {
    return await calculateLeaderboardRealtime();
  }
};

// æ ¹æ®åœºæ™¯é€‰æ‹©
async function getLeaderboard(mode: 'fast' | 'accurate' = 'fast') {
  if (mode === 'fast') {
    return await dataLayers.fast() || await dataLayers.medium();
  } else {
    return await dataLayers.accurate();
  }
}
```

#### ä¹è§‚æ›´æ–°ï¼ˆOptimistic Updateï¼‰

```typescript
// å‰ç«¯ç«‹å³æ˜¾ç¤ºï¼Œåå°æ…¢æ…¢åŒæ­¥
function useOptimisticUpdate() {
  const [data, setData] = useState(null);
  
  const updateData = async (newData) => {
    // ç«‹å³æ›´æ–°UI
    setData(newData);
    
    // åå°éªŒè¯å¹¶åŒæ­¥
    try {
      const verified = await verifyData(newData);
      if (verified !== newData) {
        setData(verified); // çº æ­£é”™è¯¯
      }
    } catch (error) {
      // å›æ»šåˆ°æ—§æ•°æ®
      setData(oldData);
    }
  };
  
  return [data, updateData];
}
```

---

## 7ï¸âƒ£ å¤§æ•°æ®é‡æ¸²æŸ“æ€§èƒ½

### é—®é¢˜æè¿°
- äº¤æ˜“å†å²å¯èƒ½æœ‰æ•°åƒæ¡
- å¯¹è¯è®°å½•å¯èƒ½æœ‰æ•°åƒæ¡
- å…¨éƒ¨æ¸²æŸ“ä¼šå¡é¡¿

### è§£å†³æ–¹æ¡ˆ

#### è™šæ‹Ÿæ»šåŠ¨ï¼ˆVirtual Scrollingï¼‰

```typescript
// components/VirtualTradeList.tsx
import { FixedSizeList } from 'react-window';

export function VirtualTradeList({ trades }) {
  const Row = ({ index, style }) => {
    const trade = trades[index];
    
    return (
      <div style={style} className="trade-row">
        <TradeCard trade={trade} />
      </div>
    );
  };
  
  return (
    <FixedSizeList
      height={600}         // å¯è§åŒºåŸŸé«˜åº¦
      itemCount={trades.length}
      itemSize={100}       // æ¯è¡Œé«˜åº¦
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

#### åˆ†é¡µåŠ è½½

```typescript
// æ— é™æ»šåŠ¨
function useInfiniteScroll(fetchMore: Function) {
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  
  const loadMore = async () => {
    const newData = await fetchMore(page);
    if (newData.length === 0) {
      setHasMore(false);
    } else {
      setPage(page + 1);
    }
  };
  
  return { loadMore, hasMore };
}
```

---

## 8ï¸âƒ£ å¤šæ¨¡å‹å¹¶å‘è°ƒç”¨

### é—®é¢˜æè¿°
- 6ä¸ªLLM APIåŒæ—¶è°ƒç”¨
- æŸä¸ªAPIå¤±è´¥ä¸åº”å½±å“å…¶ä»–
- è¶…æ—¶å¤„ç†

### è§£å†³æ–¹æ¡ˆ

```typescript
async function callAllModelsWithTimeout(prompt: string) {
  const timeout = 30000; // 30ç§’è¶…æ—¶
  
  const modelCalls = adapters.map(async (adapter, modelId) => {
    try {
      const result = await Promise.race([
        adapter.callModel(prompt),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Timeout')), timeout)
        )
      ]);
      
      return { modelId, success: true, result };
    } catch (error) {
      console.error(`Model ${modelId} failed:`, error);
      return { 
        modelId, 
        success: false, 
        error: error.message,
        fallback: { action: 'HOLD' } // é™çº§ç­–ç•¥
      };
    }
  });
  
  // ç­‰å¾…æ‰€æœ‰è°ƒç”¨å®Œæˆï¼ˆåŒ…æ‹¬å¤±è´¥çš„ï¼‰
  const results = await Promise.allSettled(modelCalls);
  
  return results.map(r => r.status === 'fulfilled' ? r.value : null);
}
```

---

## 9ï¸âƒ£ å›¾è¡¨æ€§èƒ½ä¼˜åŒ–

### é—®é¢˜æè¿°
- æ•°æ®ç‚¹è¿‡å¤šï¼ˆæ•°åƒä¸ªï¼‰
- å®æ—¶æ›´æ–°å¯¼è‡´é‡ç»˜
- ç§»åŠ¨ç«¯æ€§èƒ½å·®

### è§£å†³æ–¹æ¡ˆ

#### æ•°æ®æŠ½æ ·

```typescript
function downsampleData(data: DataPoint[], maxPoints = 500): DataPoint[] {
  if (data.length <= maxPoints) return data;
  
  const step = Math.ceil(data.length / maxPoints);
  return data.filter((_, index) => index % step === 0);
}
```

#### Canvasæ¸²æŸ“ï¼ˆè€ŒéSVGï¼‰

```typescript
// Chart.jsé»˜è®¤ä½¿ç”¨Canvasï¼Œæ€§èƒ½å¥½
const options = {
  animation: {
    duration: 0 // ç¦ç”¨åŠ¨ç”»æå‡æ€§èƒ½
  },
  elements: {
    point: {
      radius: 0 // ä¸æ˜¾ç¤ºç‚¹ï¼Œä»…æ˜¾ç¤ºçº¿
    }
  }
};
```

#### React.memoä¼˜åŒ–

```typescript
export const Chart = React.memo(({ data }) => {
  return <Line data={data} options={options} />;
}, (prevProps, nextProps) => {
  // è‡ªå®šä¹‰æ¯”è¾ƒï¼Œä»…å½“æ•°æ®çœŸæ­£å˜åŒ–æ—¶é‡æ¸²æŸ“
  return JSON.stringify(prevProps.data) === JSON.stringify(nextProps.data);
});
```

---

## ğŸ”Ÿ é’±åŒ…å®‰å…¨

### é—®é¢˜æè¿°
- ç§é’¥æ³„éœ²é£é™©
- äº¤æ˜“è¢«ç¯¡æ”¹
- èµ„é‡‘è¢«ç›—

### è§£å†³æ–¹æ¡ˆ

#### ç§é’¥ç®¡ç†

```typescript
// âŒ é”™è¯¯åšæ³•ï¼šç¡¬ç¼–ç 
const PRIVATE_KEY = '0x1234...';

// âœ… æ­£ç¡®åšæ³•ï¼šç¯å¢ƒå˜é‡ + åŠ å¯†
import { decrypt } from './crypto';

const ENCRYPTED_KEY = process.env.ENCRYPTED_PRIVATE_KEY;
const ENCRYPTION_PASSWORD = process.env.KEY_PASSWORD;

const privateKey = decrypt(ENCRYPTED_KEY, ENCRYPTION_PASSWORD);
```

#### å¤šé‡ç­¾åï¼ˆå¯é€‰ï¼‰

```typescript
// å¤§é¢äº¤æ˜“éœ€è¦å¤šé‡ç¡®è®¤
async function executeWithApproval(trade: Trade) {
  if (trade.notional > 20000) { // $20kä»¥ä¸Š
    // å‘é€å®¡æ‰¹è¯·æ±‚
    await sendApprovalRequest(trade);
    
    // ç­‰å¾…äººå·¥ç¡®è®¤
    const approved = await waitForApproval(trade.id, 300000); // 5åˆ†é’Ÿ
    
    if (!approved) {
      throw new Error('Trade not approved');
    }
  }
  
  return await executeTrade(trade);
}
```

#### å¼‚å¸¸ç›‘æ§

```typescript
// å®æ—¶ç›‘æ§å¼‚å¸¸äº¤æ˜“
async function monitorTrade(trade: Trade) {
  // æ£€æµ‹å¼‚å¸¸
  const anomalies = [];
  
  // 1. æ æ†è¿‡é«˜
  if (trade.leverage > 20) {
    anomalies.push('Leverage exceeds 20X');
  }
  
  // 2. å•ç¬”è¿‡å¤§
  if (trade.size_usd > 30000) {
    anomalies.push('Trade size exceeds $30k');
  }
  
  // 3. é¢‘ç‡è¿‡é«˜
  const recentTrades = await getRecentTrades(trade.modelId, 3600);
  if (recentTrades.length > 10) {
    anomalies.push('More than 10 trades in 1 hour');
  }
  
  if (anomalies.length > 0) {
    // å‘é€å‘Šè­¦
    await sendAlert({
      level: 'WARNING',
      message: `Anomaly detected in ${trade.modelId}`,
      details: anomalies
    });
  }
}
```

---

## ğŸ› é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

### åˆ†çº§é”™è¯¯å¤„ç†

```typescript
class AppError extends Error {
  constructor(
    message: string,
    public level: 'INFO' | 'WARNING' | 'ERROR' | 'CRITICAL',
    public context?: any
  ) {
    super(message);
  }
}

// ä½¿ç”¨
try {
  await executeTrade(decision);
} catch (error) {
  if (error instanceof AppError) {
    switch (error.level) {
      case 'CRITICAL':
        // å‘é€ç´§æ€¥å‘Šè­¦
        await sendPagerDutyAlert(error);
        break;
      case 'ERROR':
        // è®°å½•æ—¥å¿— + å‘é€é‚®ä»¶
        logger.error(error);
        await sendEmailAlert(error);
        break;
      case 'WARNING':
        // ä»…è®°å½•æ—¥å¿—
        logger.warn(error);
        break;
    }
  } else {
    // æœªçŸ¥é”™è¯¯ï¼ŒæŒ‰CRITICALå¤„ç†
    logger.critical('Unknown error:', error);
  }
}
```

### å‰ç«¯é”™è¯¯è¾¹ç•Œ

```typescript
// components/ErrorBoundary.tsx
import { Component, ReactNode } from 'react';

export class ErrorBoundary extends Component<
  { children: ReactNode },
  { hasError: boolean; error?: Error }
> {
  state = { hasError: false };
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: any) {
    console.error('React error:', error, errorInfo);
    
    // å‘é€åˆ°Sentry
    Sentry.captureException(error, { extra: errorInfo });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-container">
          <h2>Something went wrong</h2>
          <button onClick={() => window.location.reload()}>
            Reload Page
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•

```typescript
// __tests__/llm/gpt5.test.ts
import { GPT5Adapter } from '@/lib/llm/gpt5';

describe('GPT5Adapter', () => {
  it('should parse valid JSON response', async () => {
    const adapter = new GPT5Adapter();
    const mockPrompt = 'Test prompt';
    
    // Mock API response
    global.fetch = jest.fn(() =>
      Promise.resolve({
        json: () => Promise.resolve({
          choices: [{
            message: {
              content: '{"action":"BUY","coin":"BTC"}'
            }
          }]
        })
      })
    );
    
    const result = await adapter.callModel(mockPrompt);
    
    expect(result.decision.action).toBe('BUY');
    expect(result.decision.coin).toBe('BTC');
  });
  
  it('should handle API errors gracefully', async () => {
    global.fetch = jest.fn(() => Promise.reject(new Error('API Error')));
    
    const adapter = new GPT5Adapter();
    
    await expect(adapter.callModel('test')).rejects.toThrow('API Error');
  });
});
```

### E2Eæµ‹è¯•

```typescript
// e2e/leaderboard.spec.ts
import { test, expect } from '@playwright/test';

test('Leaderboardæ˜¾ç¤ºæ­£ç¡®æ’å', async ({ page }) => {
  await page.goto('https://nof1.ai/leaderboard');
  
  // ç­‰å¾…æ•°æ®åŠ è½½
  await page.waitForSelector('[data-testid="leaderboard-table"]');
  
  // æ£€æŸ¥ç¬¬ä¸€å
  const firstPlace = await page.locator('tbody tr:first-child').textContent();
  expect(firstPlace).toContain('DeepSeek');
  
  // æ£€æŸ¥æ’åºåŠŸèƒ½
  await page.click('th:has-text("RETURN %")');
  await page.waitForTimeout(500);
  
  const firstAfterSort = await page.locator('tbody tr:first-child').textContent();
  // åº”è¯¥æ˜¾ç¤ºå›æŠ¥ç‡æœ€é«˜çš„
});
```

---

## ğŸ” è°ƒè¯•æŠ€å·§

### æ—¥å¿—ç³»ç»Ÿ

```typescript
// lib/logger.ts
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
    new winston.transports.Console({ format: winston.format.simple() })
  ]
});

// ä½¿ç”¨
logger.info('AI decision cycle started', { modelId: 'deepseek-chat-v3.1' });
logger.error('Trade execution failed', { error, trade });
```

### äº¤æ˜“å®¡è®¡æ—¥å¿—

```sql
-- å®¡è®¡è¡¨
CREATE TABLE audit_log (
  id SERIAL PRIMARY KEY,
  event_type VARCHAR(50),
  model_id VARCHAR(50),
  details JSONB,
  timestamp TIMESTAMP DEFAULT NOW()
);

-- è®°å½•æ‰€æœ‰å…³é”®æ“ä½œ
INSERT INTO audit_log (event_type, model_id, details)
VALUES ('TRADE_EXECUTED', 'deepseek-chat-v3.1', '{"coin":"BTC","side":"LONG"}');
```

---

## ğŸš€ éƒ¨ç½²æœ€ä½³å®è·µ

### ç¯å¢ƒéš”ç¦»

```bash
# .env.local (å¼€å‘ç¯å¢ƒ)
DATABASE_URL=postgresql://localhost:5432/alpharena_dev
REDIS_URL=redis://localhost:6379
OPENAI_API_KEY=sk-test-...

# .env.production (ç”Ÿäº§ç¯å¢ƒ)
DATABASE_URL=postgresql://prod.supabase.co:5432/alpharena
REDIS_URL=redis://prod.upstash.com:6379
OPENAI_API_KEY=sk-prod-...
```

### é›¶åœæœºéƒ¨ç½²

```yaml
# vercel.json
{
  "github": {
    "silent": true
  },
  "buildCommand": "prisma generate && next build",
  "headers": [
    {
      "source": "/api/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "s-maxage=10, stale-while-revalidate"
        }
      ]
    }
  ]
}
```

### å¥åº·æ£€æŸ¥ç«¯ç‚¹

```typescript
// pages/api/health.ts
export default async function handler(req, res) {
  try {
    // æ£€æŸ¥æ•°æ®åº“è¿æ¥
    await db.query('SELECT 1');
    
    // æ£€æŸ¥Redisè¿æ¥
    await redis.ping();
    
    // æ£€æŸ¥Hyperliquidè¿æ¥
    await hyperliquid.ping();
    
    res.status(200).json({
      status: 'OK',
      timestamp: new Date().toISOString(),
      services: {
        database: 'UP',
        redis: 'UP',
        hyperliquid: 'UP'
      }
    });
  } catch (error) {
    res.status(500).json({
      status: 'ERROR',
      error: error.message
    });
  }
}
```

---

## å¯¼èˆª

- [â† è¿”å›ä¸»ç›®å½•](../README.md)
- [â† ä¸Šä¸€ç« ï¼šå¼€å‘æŒ‡å—](07-å¼€å‘æŒ‡å—.md)
- [ä¸‹ä¸€ç« ï¼šæ‰©å±•åŠŸèƒ½å»ºè®® â†’](09-æ‰©å±•åŠŸèƒ½.md)


