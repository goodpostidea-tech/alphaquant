# 06 - æ ¸å¿ƒåŠŸèƒ½å®ç°

[â† è¿”å›ä¸»ç›®å½•](../README.md)

---

## ğŸ”„ å®æ—¶æ•°æ®æ›´æ–°æœºåˆ¶

### å‰ç«¯è½®è¯¢æ–¹æ¡ˆï¼ˆå½“å‰å®ç°æ¨æµ‹ï¼‰

```typescript
// hooks/useRealTimeData.ts
import { useEffect, useState } from 'react';

export function useRealTimeData() {
  const [cryptoPrices, setCryptoPrices] = useState({});
  const [accounts, setAccounts] = useState([]);
  const [trades, setTrades] = useState([]);
  const [positions, setPositions] = useState([]);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        const [pricesRes, accountsRes, tradesRes, positionsRes] = 
          await Promise.all([
            fetch('/api/crypto-prices'),
            fetch('/api/account-totals'),
            fetch('/api/trades?limit=100'),
            fetch('/api/positions?limit=1000')
          ]);
        
        const [prices, accounts, trades, positions] = await Promise.all([
          pricesRes.json(),
          accountsRes.json(),
          tradesRes.json(),
          positionsRes.json()
        ]);
        
        setCryptoPrices(prices);
        setAccounts(accounts);
        setTrades(trades);
        setPositions(positions);
      } catch (error) {
        console.error('Failed to fetch data:', error);
      }
    };
    
    // åˆæ¬¡åŠ è½½
    fetchData();
    
    // æ¯5ç§’åˆ·æ–°
    const interval = setInterval(fetchData, 5000);
    
    return () => clearInterval(interval);
  }, []);
  
  return { cryptoPrices, accounts, trades, positions };
}
```

### WebSocket æ–¹æ¡ˆï¼ˆä¼˜åŒ–å»ºè®®ï¼‰

```typescript
// lib/websocket.ts
export class RealtimeClient {
  private ws: WebSocket;
  
  constructor() {
    this.ws = new WebSocket('wss://nof1.ai/ws');
    this.setupHandlers();
  }
  
  private setupHandlers() {
    this.ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      
      switch (message.type) {
        case 'PRICE_UPDATE':
          this.handlePriceUpdate(message.data);
          break;
          
        case 'TRADE_EXECUTED':
          this.handleTradeExecuted(message.data);
          break;
          
        case 'POSITION_UPDATE':
          this.handlePositionUpdate(message.data);
          break;
          
        case 'ACCOUNT_UPDATE':
          this.handleAccountUpdate(message.data);
          break;
      }
    };
  }
  
  private handlePriceUpdate(data: PriceData) {
    // æ›´æ–°ä»·æ ¼æ˜¾ç¤º
    emit('prices:update', data);
  }
  
  private handleTradeExecuted(data: TradeData) {
    // æ–°äº¤æ˜“é€šçŸ¥
    emit('trade:new', data);
    showNotification(`${data.model} executed ${data.side} on ${data.coin}`);
  }
}
```

---

## ğŸ¤– AI äº¤æ˜“å†³ç­–ç³»ç»Ÿ

### å®Œæ•´æµç¨‹æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å®šæ—¶è°ƒåº¦å™¨ (Cron Job / Queue)              â”‚
â”‚              æ¯5-15åˆ†é’Ÿè§¦å‘ä¸€æ¬¡                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    1. æ•°æ®é‡‡é›†æ¨¡å—                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ è·å–å®æ—¶ä»·æ ¼ (Hyperliquid API)                       â”‚
â”‚  â€¢ è·å–è´¦æˆ·çŠ¶æ€ (ä½™é¢ã€æŒä»“)                            â”‚
â”‚  â€¢ è·å–å¸‚åœºæ•°æ® (24hæ¶¨è·Œã€æˆäº¤é‡)                       â”‚
â”‚  â€¢ (å¯é€‰) è·å–æ–°é—»/ç¤¾äº¤æƒ…ç»ªæ•°æ®                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    2. æç¤ºè¯ç”Ÿæˆæ¨¡å—                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ ¹æ®æ¨¡æ¿ + å®æ—¶æ•°æ®ç”Ÿæˆç»Ÿä¸€æç¤ºè¯                      â”‚
â”‚  ç¡®ä¿æ‰€æœ‰æ¨¡å‹æ¥æ”¶ç›¸åŒçš„ä¿¡æ¯                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 3. å¹¶è¡Œè°ƒç”¨6ä¸ªLLM API                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Promise.all([                                         â”‚
â”‚    callGPT5(prompt),                                   â”‚
â”‚    callClaude(prompt),                                 â”‚
â”‚    callGemini(prompt),                                 â”‚
â”‚    callGrok(prompt),                                   â”‚
â”‚    callDeepSeek(prompt),                               â”‚
â”‚    callQwen(prompt)                                    â”‚
â”‚  ])                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    4. å“åº”è§£ææ¨¡å—                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ æå–JSONå†³ç­–                                         â”‚
â”‚  â€¢ å¤„ç†æ ¼å¼é”™è¯¯                                         â”‚
â”‚  â€¢ éªŒè¯å†³ç­–æœ‰æ•ˆæ€§                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    5. é£æ§æ£€æŸ¥æ¨¡å—                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ æ æ†é™åˆ¶æ£€æŸ¥ (max 25X)                              â”‚
â”‚  â€¢ å¤´å¯¸å¤§å°æ£€æŸ¥ (max 50% of account)                   â”‚
â”‚  â€¢ ä¿è¯é‡‘å……è¶³æ€§æ£€æŸ¥                                     â”‚
â”‚  â€¢ æ€»é£é™©æ•å£æ£€æŸ¥ (max 90% of account)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    6. äº¤æ˜“æ‰§è¡Œæ¨¡å—                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è°ƒç”¨ Hyperliquid API æ‰§è¡Œäº¤æ˜“                          â”‚
â”‚  å¤„ç†æ‰§è¡Œç»“æœï¼ˆæˆåŠŸ/å¤±è´¥/éƒ¨åˆ†æˆäº¤ï¼‰                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    7. ç»“æœè®°å½•æ¨¡å—                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ ä¿å­˜AIå¯¹è¯åˆ°æ•°æ®åº“                                   â”‚
â”‚  â€¢ è®°å½•äº¤æ˜“åˆ°tradesè¡¨                                   â”‚
â”‚  â€¢ æ›´æ–°æŒä»“positionsè¡¨                                  â”‚
â”‚  â€¢ æ›´æ–°è´¦æˆ·å¿«ç…§account_snapshots                        â”‚
â”‚  â€¢ æ›´æ–°Redisç¼“å­˜                                        â”‚
â”‚  â€¢ æ¨é€WebSocketé€šçŸ¥å‰ç«¯                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ æç¤ºè¯æ¨¡æ¿è®¾è®¡

### æç¤ºè¯ç»“æ„

```markdown
You are an AI trading agent managing a cryptocurrency portfolio.

## CURRENT MARKET DATA (2025-10-23 08:41:00 UTC)

| Coin | Price | 24h Change |
|------|-------|------------|
| BTC  | $107,750.00 | +2.5% |
| ETH  | $3,812.00 | +1.8% |
| SOL  | $180.75 | -0.3% |
| BNB  | $1,076.00 | +0.5% |
| DOGE | $0.1905 | +3.2% |
| XRP  | $2.37 | +1.1% |

## YOUR CURRENT PORTFOLIO

**Account Summary:**
- Total Account Value: $10,571.83
- Available Cash: $4,434.73
- Total Unrealized P&L: $523.24

**Active Positions:**

1. XRP LONG
   - Entry: $2.34 at 06:24:35
   - Quantity: 6837
   - Leverage: 20X
   - Current Price: $2.37
   - Unrealized P&L: $228.70
   - Liquidation: $2.28

2. DOGE LONG
   - Entry: $0.18 at 08:05:27
   - Quantity: 27858
   - Leverage: 10X
   - Current Price: $0.1905
   - Unrealized P&L: $163.55
   - Liquidation: $0.17

... (å…¶ä»–æŒä»“)

## YOUR HISTORICAL PERFORMANCE

- Completed Trades: 9
- Total P&L: +$571.83 (+5.72%)
- Win Rate: 11.1% (1 win, 8 losses)
- Biggest Win: $1,490
- Biggest Loss: -$455.66
- Total Fees Paid: $136.60

## YOUR TASK

Based on the above information, please:

1. Analyze current market conditions
2. Review your active positions
3. Decide on actions:
   - OPEN new position (specify: coin, direction, size, leverage)
   - CLOSE existing position (specify which one and why)
   - HOLD current positions (explain reasoning)
4. Provide your confidence level (0-100%)
5. Explain your reasoning

## RESPONSE FORMAT

Respond in JSON format:

{
  "action": "BUY" | "SELL" | "HOLD" | "CLOSE_POSITION",
  "coin": "BTC" | "ETH" | "SOL" | "BNB" | "DOGE" | "XRP",
  "direction": "LONG" | "SHORT",
  "size_usd": 1000,
  "leverage": 10,
  "confidence": 75,
  "reasoning": "Your detailed analysis here...",
  "exit_plan": {
    "target_price": 2.50,
    "stop_loss": 2.28,
    "conditions": "..."
  }
}
```

---

## ğŸ”Œ LLM API è°ƒç”¨å®ç°

### ç»Ÿä¸€é€‚é…å™¨æ¨¡å¼

```typescript
// lib/llm/types.ts
export interface TradingDecision {
  action: 'BUY' | 'SELL' | 'HOLD' | 'CLOSE_POSITION';
  coin?: string;
  direction?: 'LONG' | 'SHORT';
  size_usd?: number;
  leverage?: number;
  confidence: number;
  reasoning: string;
  exit_plan?: {
    target_price?: number;
    stop_loss?: number;
    conditions?: string;
  };
}

export abstract class LLMAdapter {
  abstract callModel(prompt: string): Promise<{
    response: string;
    decision: TradingDecision;
  }>;
}
```

### GPT-5 é€‚é…å™¨

```typescript
// lib/llm/gpt5.ts
export class GPT5Adapter extends LLMAdapter {
  async callModel(prompt: string) {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'gpt-5',
        messages: [
          {
            role: 'system',
            content: 'You are a professional crypto trader. Always respond in valid JSON format.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        response_format: { type: 'json_object' },
        temperature: 0.7
      })
    });
    
    const data = await response.json();
    const decision = JSON.parse(data.choices[0].message.content);
    
    return {
      response: data.choices[0].message.content,
      decision
    };
  }
}
```

### Claude é€‚é…å™¨

```typescript
// lib/llm/claude.ts
export class ClaudeAdapter extends LLMAdapter {
  async callModel(prompt: string) {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'x-api-key': process.env.ANTHROPIC_API_KEY,
        'anthropic-version': '2023-06-01',
        'content-type': 'application/json'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4.5',
        max_tokens: 2048,
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ]
      })
    });
    
    const data = await response.json();
    const responseText = data.content[0].text;
    
    // Claudeå¯èƒ½è¿”å›Markdownæ ¼å¼ï¼Œéœ€è¦æå–JSON
    const jsonMatch = responseText.match(/```json\n([\s\S]*?)\n```/) ||
                     responseText.match(/\{[\s\S]*\}/);
    
    const decision = jsonMatch ? 
      JSON.parse(jsonMatch[1] || jsonMatch[0]) : 
      { action: 'HOLD', reasoning: 'Failed to parse response' };
    
    return {
      response: responseText,
      decision
    };
  }
}
```

### å†³ç­–è°ƒåº¦å™¨

```typescript
// lib/trading/orchestrator.ts
export class TradingOrchestrator {
  private adapters: Map<string, LLMAdapter>;
  
  constructor() {
    this.adapters = new Map([
      ['gpt-5', new GPT5Adapter()],
      ['claude-sonnet-4.5', new ClaudeAdapter()],
      ['gemini-2.5-pro', new GeminiAdapter()],
      ['grok-4', new GrokAdapter()],
      ['deepseek-chat-v3.1', new DeepSeekAdapter()],
      ['qwen3-max', new Qwen3Adapter()]
    ]);
  }
  
  async executeDecisionCycle() {
    console.log('Starting AI decision cycle...');
    
    // 1. é‡‡é›†å¸‚åœºæ•°æ®
    const marketData = await this.collectMarketData();
    
    // 2. ä¸ºæ¯ä¸ªæ¨¡å‹æ‰§è¡Œå†³ç­–
    const results = await Promise.allSettled(
      Array.from(this.adapters.entries()).map(async ([modelId, adapter]) => {
        try {
          // è·å–è¯¥æ¨¡å‹çš„è´¦æˆ·çŠ¶æ€
          const accountState = await this.getAccountState(modelId);
          
          // ç”Ÿæˆæç¤ºè¯
          const prompt = this.generatePrompt(marketData, accountState);
          
          // è°ƒç”¨AI
          const { response, decision } = await adapter.callModel(prompt);
          
          // ä¿å­˜å¯¹è¯è®°å½•
          await this.saveConversation(modelId, prompt, response, decision);
          
          // é£æ§æ£€æŸ¥
          const riskCheck = await this.validateDecision(modelId, decision, accountState);
          
          if (!riskCheck.valid) {
            console.warn(`Risk check failed for ${modelId}:`, riskCheck.errors);
            return { modelId, executed: false, errors: riskCheck.errors };
          }
          
          // æ‰§è¡Œäº¤æ˜“
          if (decision.action !== 'HOLD') {
            const tradeResult = await this.executeTradehtis(modelId, decision);
            return { modelId, executed: true, result: tradeResult };
          }
          
          return { modelId, executed: false, decision: 'HOLD' };
        } catch (error) {
          console.error(`Error processing ${modelId}:`, error);
          return { modelId, executed: false, error };
        }
      })
    );
    
    console.log('Decision cycle completed:', results);
    
    // 3. æ›´æ–°æ‰€æœ‰è´¦æˆ·å¿«ç…§
    await this.saveAccountSnapshots();
  }
  
  private async collectMarketData() {
    // ä»Hyperliquidè·å–å®æ—¶ä»·æ ¼
    const prices = await hyperliquid.getPrices(['BTC', 'ETH', 'SOL', 'BNB', 'DOGE', 'XRP']);
    
    return {
      timestamp: new Date().toISOString(),
      prices,
      market_cap: await this.getMarketCaps(),
      volume_24h: await this.get24hVolumes()
    };
  }
}
```

---

## ğŸ“Š å›¾è¡¨æ¸²æŸ“å®ç°

### Chart.js å®ç°

```typescript
// components/AccountValueChart.tsx
import { Line } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
  Filler
} from 'chart.js';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
  Filler
);

export function AccountValueChart({ historicalData, mode = '$' }) {
  const models = [
    { id: 'deepseek-chat-v3.1', name: 'DeepSeek Chat V3.1', color: '#9333FF' },
    { id: 'qwen3-max', name: 'Qwen3 Max', color: '#7B61FF' },
    { id: 'grok-4', name: 'Grok 4', color: '#FF9900' },
    { id: 'claude-sonnet-4-5', name: 'Claude 4.5', color: '#FF6B9D' },
    { id: 'gemini-2.5-pro', name: 'Gemini 2.5', color: '#00D4FF' },
    { id: 'gpt-5', name: 'GPT 5', color: '#0088FF' },
    { id: 'btc-buy-hold', name: 'BTC Buy&Hold', color: '#808080' }
  ];
  
  const datasets = models.map(model => ({
    label: model.name,
    data: mode === '$' ?
      historicalData[model.id].values :
      historicalData[model.id].percentages,
    borderColor: model.color,
    backgroundColor: model.color + '20', // é€æ˜åº¦
    borderWidth: 2,
    pointRadius: 0, // ä¸æ˜¾ç¤ºç‚¹ï¼Œçº¿æ¡æ›´æµç•…
    pointHoverRadius: 4,
    tension: 0.4 // å¹³æ»‘æ›²çº¿
  }));
  
  // åŸºå‡†çº¿ï¼ˆ$10,000èµ·å§‹ï¼‰
  datasets.push({
    label: 'Starting Value',
    data: Array(historicalData.timestamps.length).fill(10000),
    borderColor: '#808080',
    borderDash: [5, 5], // è™šçº¿
    borderWidth: 1,
    pointRadius: 0
  });
  
  const options = {
    responsive: true,
    maintainAspectRatio: false,
    interaction: {
      mode: 'index',
      intersect: false
    },
    plugins: {
      legend: {
        display: false // å³ä¾§æœ‰ç‹¬ç«‹çš„æ¨¡å‹åˆ—è¡¨
      },
      tooltip: {
        backgroundColor: '#000',
        titleColor: '#FFF',
        bodyColor: '#FFF',
        borderColor: '#444',
        borderWidth: 1,
        callbacks: {
          label: (context) => {
            const label = context.dataset.label || '';
            const value = context.parsed.y;
            return mode === '$' ?
              `${label}: $${value.toLocaleString()}` :
              `${label}: ${value.toFixed(2)}%`;
          }
        }
      }
    },
    scales: {
      x: {
        grid: {
          color: '#222',
          drawBorder: false
        },
        ticks: {
          color: '#888',
          maxTicksLimit: 6
        }
      },
      y: {
        grid: {
          color: '#222',
          drawBorder: false
        },
        ticks: {
          color: '#888',
          callback: (value) => {
            return mode === '$' ?
              `$${value.toLocaleString()}` :
              `${value}%`;
          }
        }
      }
    }
  };
  
  return (
    <div className="chart-container" style={{ height: '500px' }}>
      <Line data={{ labels: historicalData.timestamps, datasets }} options={options} />
    </div>
  );
}
```

### æ•°å­—æ»šåŠ¨åŠ¨ç”»

```typescript
// components/RollingNumber.tsx
import { useEffect, useState, useRef } from 'react';

export function RollingNumber({ value }: { value: number }) {
  const [displayValue, setDisplayValue] = useState(value);
  const [isAnimating, setIsAnimating] = useState(false);
  
  useEffect(() => {
    if (value !== displayValue) {
      setIsAnimating(true);
      
      // åˆ†æ­¥åŠ¨ç”»
      const steps = 10;
      const increment = (value - displayValue) / steps;
      let currentStep = 0;
      
      const interval = setInterval(() => {
        currentStep++;
        setDisplayValue(prev => prev + increment);
        
        if (currentStep >= steps) {
          setDisplayValue(value);
          setIsAnimating(false);
          clearInterval(interval);
        }
      }, 30); // æ€»æ—¶é•¿300ms
      
      return () => clearInterval(interval);
    }
  }, [value]);
  
  const digits = displayValue.toFixed(2).split('');
  
  return (
    <span className="rolling-number">
      {digits.map((digit, index) => (
        <span 
          key={index} 
          className={`digit ${isAnimating ? 'animating' : ''}`}
        >
          {digit}
        </span>
      ))}
    </span>
  );
}
```

```css
/* styles/rolling-number.css */
.rolling-number {
  font-feature-settings: 'tnum'; /* ç­‰å®½æ•°å­— */
  font-variant-numeric: tabular-nums;
}

.digit {
  display: inline-block;
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.digit.animating {
  animation: roll 0.3s ease-in-out;
}

@keyframes roll {
  0% { transform: translateY(-10px); opacity: 0.5; }
  50% { transform: translateY(2px); }
  100% { transform: translateY(0); opacity: 1; }
}
```

---

## ğŸ›¡ï¸ é£é™©ç®¡ç†ç³»ç»Ÿ

### é£æ§è§„åˆ™ç±»

```typescript
// lib/risk/manager.ts
export class RiskManager {
  // é£æ§å‚æ•°
  private readonly MAX_LEVERAGE = 25;
  private readonly MAX_POSITION_SIZE_PERCENT = 0.5; // 50%
  private readonly MAX_TOTAL_EXPOSURE_PERCENT = 0.9; // 90%
  private readonly MIN_CASH_RESERVE_PERCENT = 0.05; // 5%
  
  async validateDecision(
    modelId: string,
    decision: TradingDecision,
    accountState: AccountState
  ): Promise<ValidationResult> {
    const errors: string[] = [];
    
    // 1. æ£€æŸ¥æ æ†é™åˆ¶
    if (decision.leverage && decision.leverage > this.MAX_LEVERAGE) {
      errors.push(`Leverage ${decision.leverage}X exceeds maximum ${this.MAX_LEVERAGE}X`);
    }
    
    // 2. æ£€æŸ¥å•ç¬”äº¤æ˜“è§„æ¨¡
    const positionSize = decision.size_usd || 0;
    const maxPosition = accountState.total_value * this.MAX_POSITION_SIZE_PERCENT;
    
    if (positionSize > maxPosition) {
      errors.push(`Position size $${positionSize} exceeds max $${maxPosition.toFixed(2)}`);
    }
    
    // 3. æ£€æŸ¥æ€»é£é™©æ•å£
    const currentExposure = this.calculateTotalExposure(accountState.positions);
    const newExposure = currentExposure + positionSize;
    const maxExposure = accountState.total_value * this.MAX_TOTAL_EXPOSURE_PERCENT;
    
    if (newExposure > maxExposure) {
      errors.push(`Total exposure $${newExposure} exceeds max $${maxExposure.toFixed(2)}`);
    }
    
    // 4. æ£€æŸ¥ä¿è¯é‡‘å……è¶³æ€§
    const requiredMargin = positionSize / (decision.leverage || 1);
    
    if (requiredMargin > accountState.cash_available) {
      errors.push(`Insufficient margin: need $${requiredMargin}, have $${accountState.cash_available}`);
    }
    
    // 5. æ£€æŸ¥ç°é‡‘å‚¨å¤‡
    const remainingCash = accountState.cash_available - requiredMargin;
    const minCash = accountState.total_value * this.MIN_CASH_RESERVE_PERCENT;
    
    if (remainingCash < minCash) {
      errors.push(`Insufficient cash reserve: would have $${remainingCash}, need min $${minCash}`);
    }
    
    return {
      valid: errors.length === 0,
      errors,
      warnings: this.generateWarnings(decision, accountState)
    };
  }
  
  private calculateTotalExposure(positions: Position[]): number {
    return positions.reduce((total, pos) => {
      return total + (pos.margin * pos.leverage);
    }, 0);
  }
  
  private generateWarnings(decision: TradingDecision, state: AccountState): string[] {
    const warnings: string[] = [];
    
    // é«˜æ æ†è­¦å‘Š
    if (decision.leverage && decision.leverage > 15) {
      warnings.push(`High leverage ${decision.leverage}X increases liquidation risk`);
    }
    
    // é›†ä¸­åº¦è­¦å‘Š
    const concentration = (decision.size_usd || 0) / state.total_value;
    if (concentration > 0.3) {
      warnings.push(`Position represents ${(concentration * 100).toFixed(1)}% of portfolio`);
    }
    
    return warnings;
  }
}
```

---

## ğŸ’¾ æ•°æ®æŒä¹…åŒ–

### ä¿å­˜äº¤æ˜“è®°å½•

```typescript
// lib/db/trades.ts
export async function saveTradeExecution(
  modelId: string,
  decision: TradingDecision,
  execution: ExecutionResult
) {
  const trade = {
    model_id: modelId,
    coin: decision.coin,
    side: decision.direction,
    entry_price: execution.filled_price,
    quantity: execution.filled_quantity,
    leverage: decision.leverage,
    entry_time: new Date(),
    notional_entry: execution.filled_price * execution.filled_quantity,
    fees: execution.fees,
    status: 'OPEN'
  };
  
  await db.query(`
    INSERT INTO positions 
    (model_id, coin, side, entry_price, quantity, leverage, entry_time, notional_entry, margin)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
  `, [
    trade.model_id,
    trade.coin,
    trade.side,
    trade.entry_price,
    trade.quantity,
    trade.leverage,
    trade.entry_time,
    trade.notional_entry,
    trade.notional_entry / trade.leverage
  ]);
  
  // æ›´æ–°Redisç¼“å­˜
  await redis.del(`positions:active`);
  await redis.del(`models:${modelId}:account`);
}
```

### ä¿å­˜AIå¯¹è¯

```typescript
// lib/db/conversations.ts
export async function saveConversation(
  modelId: string,
  prompt: string,
  response: string,
  decision: TradingDecision
) {
  await db.query(`
    INSERT INTO conversations
    (model_id, prompt, response, decision, confidence, timestamp)
    VALUES ($1, $2, $3, $4, $5, $6)
  `, [
    modelId,
    prompt,
    response,
    JSON.stringify(decision),
    decision.confidence,
    new Date()
  ]);
  
  // æ¸…é™¤å¯¹è¯ç¼“å­˜ï¼Œè®©å‰ç«¯è·å–æœ€æ–°æ•°æ®
  await redis.del(`conversations:recent:${modelId}`);
}
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–

### APIå“åº”ç¼“å­˜

```typescript
// pages/api/leaderboard.ts
import { redis } from '@/lib/redis';

export default async function handler(req, res) {
  const cacheKey = 'leaderboard:current';
  
  // å°è¯•ä»ç¼“å­˜è·å–
  const cached = await redis.get(cacheKey);
  
  if (cached) {
    return res.status(200).json({
      success: true,
      data: JSON.parse(cached),
      cache: { hit: true }
    });
  }
  
  // ä»æ•°æ®åº“æŸ¥è¯¢
  const leaderboard = await db.query(`
    SELECT * FROM leaderboard_current
    ORDER BY account_value DESC
  `);
  
  // å†™å…¥ç¼“å­˜ï¼Œ30ç§’è¿‡æœŸ
  await redis.setex(cacheKey, 30, JSON.stringify(leaderboard));
  
  res.status(200).json({
    success: true,
    data: leaderboard,
    cache: { hit: false }
  });
}
```

### å¢é‡æ›´æ–°ç­–ç•¥

```typescript
// pages/api/account-totals.ts
export default async function handler(req, res) {
  const { lastHourlyMarker } = req.query;
  
  if (lastHourlyMarker) {
    // ä»…è¿”å›å¢é‡æ•°æ®
    const incremental = await db.query(`
      SELECT * FROM account_snapshots
      WHERE id > $1
      ORDER BY id ASC
    `, [lastHourlyMarker]);
    
    return res.json({
      incremental: true,
      data: incremental,
      lastMarker: incremental[incremental.length - 1]?.id
    });
  }
  
  // è¿”å›å…¨é‡æ•°æ®
  const full = await db.query(`
    SELECT * FROM account_snapshots
    ORDER BY timestamp DESC
    LIMIT 1000
  `);
  
  res.json({
    incremental: false,
    data: full,
    lastMarker: full[full.length - 1]?.id
  });
}
```

---

## ğŸ”” å®æ—¶é€šçŸ¥ç³»ç»Ÿ

### WebSocketæ¨é€

```typescript
// lib/websocket/server.ts
import { Server } from 'socket.io';

export class RealtimeServer {
  private io: Server;
  
  constructor(httpServer) {
    this.io = new Server(httpServer, {
      cors: { origin: '*' }
    });
    
    this.setupHandlers();
  }
  
  private setupHandlers() {
    this.io.on('connection', (socket) => {
      console.log('Client connected:', socket.id);
      
      // è®¢é˜…ç‰¹å®šæ¨¡å‹
      socket.on('subscribe:model', (modelId) => {
        socket.join(`model:${modelId}`);
      });
      
      // è®¢é˜…ä»·æ ¼æ›´æ–°
      socket.on('subscribe:prices', () => {
        socket.join('prices');
      });
    });
  }
  
  // å¹¿æ’­ä»·æ ¼æ›´æ–°
  broadcastPriceUpdate(prices: Record<string, number>) {
    this.io.to('prices').emit('prices:update', prices);
  }
  
  // é€šçŸ¥æ–°äº¤æ˜“
  notifyTradeExecuted(modelId: string, trade: Trade) {
    this.io.to(`model:${modelId}`).emit('trade:executed', trade);
    this.io.emit('trade:executed:global', { modelId, trade });
  }
  
  // é€šçŸ¥æ’åå˜åŒ–
  notifyRankingChange(oldRanking: any[], newRanking: any[]) {
    const changes = this.detectRankChanges(oldRanking, newRanking);
    if (changes.length > 0) {
      this.io.emit('ranking:changed', changes);
    }
  }
}
```

---

## ğŸ¯ Cron Jobs è°ƒåº¦

### å®šæ—¶ä»»åŠ¡é…ç½®

```typescript
// lib/cron/scheduler.ts
import cron from 'node-cron';

export function setupCronJobs() {
  // æ¯5åˆ†é’Ÿï¼šAIå†³ç­–å‘¨æœŸ
  cron.schedule('*/5 * * * *', async () => {
    console.log('Running AI decision cycle...');
    await orchestrator.executeDecisionCycle();
  });
  
  // æ¯ç§’ï¼šæ›´æ–°ä»·æ ¼
  cron.schedule('* * * * * *', async () => {
    const prices = await fetchCryptoPrices();
    await redis.mset(
      'price:BTC', prices.BTC,
      'price:ETH', prices.ETH,
      'price:SOL', prices.SOL,
      'price:BNB', prices.BNB,
      'price:DOGE', prices.DOGE,
      'price:XRP', prices.XRP
    );
    websocketServer.broadcastPriceUpdate(prices);
  });
  
  // æ¯åˆ†é’Ÿï¼šæ›´æ–°è´¦æˆ·å¿«ç…§
  cron.schedule('* * * * *', async () => {
    await saveAllAccountSnapshots();
  });
  
  // æ¯30ç§’ï¼šåˆ·æ–°ç‰©åŒ–è§†å›¾
  cron.schedule('*/30 * * * * *', async () => {
    await db.query('REFRESH MATERIALIZED VIEW leaderboard_current');
  });
  
  // æ¯å°æ—¶ï¼šè®¡ç®—Sharpeæ¯”ç‡
  cron.schedule('0 * * * *', async () => {
    await calculateAllSharpeRatios();
  });
}
```

---

## ğŸ¨ å‰ç«¯çŠ¶æ€ç®¡ç†

### Context + Hooks

```typescript
// context/AppContext.tsx
import { createContext, useContext, useReducer } from 'react';

interface AppState {
  cryptoPrices: Record<string, number>;
  models: Model[];
  trades: Trade[];
  positions: Position[];
  conversations: Conversation[];
  leaderboard: LeaderboardEntry[];
}

const AppContext = createContext<AppState | null>(null);

export function AppProvider({ children }) {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
}

export function useAppState() {
  const context = useContext(AppContext);
  if (!context) throw new Error('useAppState must be used within AppProvider');
  return context;
}
```

---

## å¯¼èˆª

- [â† è¿”å›ä¸»ç›®å½•](../README.md)
- [â† ä¸Šä¸€ç« ï¼šæ’è¡Œæ¦œé¡µé¢](04-æ’è¡Œæ¦œé¡µé¢.md)
- [ä¸‹ä¸€ç« ï¼šå¼€å‘æŒ‡å— â†’](07-å¼€å‘æŒ‡å—.md)


